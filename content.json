[{"title":"Java实现Redis、Zookeeper分布式锁","date":"2018-01-31T16:00:00.000Z","path":"2018/02/01/Java实现Redis、Zookeeper分布式锁/","text":"在单机环境下，使用volatile、synchronized关键字或者Jdk的各种并发API可以实现线程安全，但是这些在分布式环境下是无法保证线程安全的，所以在分布式环境下需要使用到分布式锁，分布式锁的实现目前有多种方案，可以使用数据库悲观、乐观锁，Redis、Memcached、Zookeeper分布式锁，下面分享Redis、Zookeeper分布式锁的实现代码。 1、Reids分布式锁private final Logger logger = LoggerFactory.getLogger(getClass()); private ShardedJedisPool shardedJedisPool; /** * 锁ID */ private final String lockId; /** * 锁命名空间 */ private final String lockNameSpace; /** * 锁key值 */ private final String lockKey; /** * 锁超时时间，防止线程在入锁以后，无限的执行等待，默认30秒 */ private static final long EXPIRE_SECS = 30; /** * 随机等待时间最小值 */ private static final int MIN_RANDOM_SECS = 10; /** * 随机等待时间最大值 */ private static final int MAX_RANDOM_SECS = 300; /** * 是否持有锁 */ private volatile boolean locked = false; public RedisLock(ShardedJedisPool shardedJedisPool, String lockNameSpace, String lockKey) { this.lockId = UUID.randomUUID().toString(); this.shardedJedisPool = shardedJedisPool; this.lockNameSpace = lockNameSpace + &quot;:&quot;; this.lockKey = lockKey; } @Override public void lock() { if (this.tryLock()) { return; } throw new RuntimeException(&quot;未能拿到锁&quot;); } @Override public void lockInterruptibly() throws InterruptedException { this.lock(); } @Override public boolean tryLock() { String lock = lockNameSpace + lockKey; if (setNxAndExpire(lock, lockId, EXPIRE_SECS)) { // 获得锁 locked = true; } return locked; } /** * Redis分布式锁 * 实现思路： * 使用了redis的set nx expire命令，缓存锁 * 执行过程： * 通过setNx尝试设置某个key的值，成功（当前没有这个锁）则返回，成功获得锁 * 失败，则等待，继续尝试获取锁，如等待超时，返回（未获得锁） * * @param time 锁等待时间 * @return * @throws InterruptedException */ @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { String lock = lockNameSpace + lockKey; long timeout = unit.toMillis(time); while (timeout &gt;= 0) { if (setNxAndExpire(lock, lockId, EXPIRE_SECS)) { // 获得锁 locked = true; return locked; } // 生成[10-200]区间的随机毫秒 long delayMills = generateRandomMills(MIN_RANDOM_SECS, MAX_RANDOM_SECS); timeout -= delayMills; logger.debug(&quot;等待锁，锁ID：{}，锁值：{}，等待时长：{}ms&quot;, lockId, lock, delayMills); /* 延迟随机毫秒,防止饥饿进程的出现,即,当同时到达多个进程,只会有一个进程获得锁,其他的都用同样的频率进行尝试, 后面有来了一些进行,也以同样的频率申请锁,这将可能导致前面来的锁得不到满足. 使用随机的等待时间可以一定程度上保证公平性 */ Thread.sleep(delayMills); } return locked; } /** * 释放锁 */ public void unlock() { if (locked) { String lock = lockNameSpace + lockKey; ShardedJedis shardedJedis = shardedJedisPool.getResource(); //避免删除非自己获取得到的锁 if (lockId.equals(shardedJedis.get(lock))) { shardedJedis.del(lock); } shardedJedis.close(); locked = false; } } @Override public Condition newCondition() { return null; } /** * 生成[min - max]区间的随机毫秒 * * @param min * @param max * @return */ private long generateRandomMills(int min, int max) { Random random = new Random(); // randNumber 将被赋值为一个 MIN 和 MAX 范围内的随机数 return random.nextInt(max - min + 1) + min; } /** * setNX命令不支持expire，所以使用set命令，同时使用nx与expire * * @param key * @param value * @param expire 毫秒 * @return */ private boolean setNxAndExpire(final String key, final String value, final long expire) { ShardedJedis shardedJedis = shardedJedisPool.getResource(); String result = shardedJedis.set(key, value, &quot;NX&quot;, &quot;PX&quot;, expire); shardedJedis.close(); return &quot;OK&quot;.equals(result); } 看的网上很多redis分布式实现都是使用setNx命令再expire，其实redis已经支持一个命令直接setNx并且给上expire，这个建议直接使用Jedis，Spring封装的ReidsTemplate中并没有找到setNx并同时给上expire的方法 2、Zookeeper分布式锁private final Logger logger = LoggerFactory.getLogger(getClass()); private ZooKeeper zooKeeper; //锁根节点 private final String lockNamespace; //锁值节点 private final String lockKey; //当前节点 private String currentNode; //等待的前一个节点 private String waitNode; //竞争的节点列表 private List&lt;String&gt; lockNodes; //计数器 private volatile CountDownLatch countDownLatch; /** * 是否持有锁 */ private volatile boolean locked = false; public ZookeeperLock(String address, int timeout, String lockNamespace, String lockKey) { init(address, timeout); this.lockNamespace = &quot;/&quot; + lockNamespace; this.lockKey = lockKey + &quot;_&quot;; } private void init(String address, int timeout) { try { zooKeeper = new ZooKeeper(address, timeout, watchedEvent -&gt; logger.debug(&quot;Zookeeper连接已建立...&quot;) ); } catch (Exception e) { logger.error(e.getMessage(), e); throw new RuntimeException(e.getMessage(), e); } } @Override public void lock() { if (this.tryLock()) { return; } throw new RuntimeException(&quot;未能拿到锁&quot;); } @Override public void lockInterruptibly() throws InterruptedException { this.lock(); } @Override public boolean tryLock() { String lock = lockNamespace + &quot;/&quot; + lockKey; try { //确保zookeeper连接成功 ensureZookeeperConnect(); //确保根节点存在 ensureNameSpaceExist(lockNamespace); //创建临时有序节点 //节点目录为/xx/xx，节点为lockKey_xxx //currentNode值为lockKey_xxx currentNode = zooKeeper.create(lock, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL).replace(lockNamespace + &quot;/&quot;, &quot;&quot;); //取出所有子节点 List&lt;String&gt; childrenList = zooKeeper.getChildren(lockNamespace, false); //竞争的节点列表 lockNodes = new ArrayList&lt;&gt;(); for (String children : childrenList) { if (children.startsWith(lockKey)) { lockNodes.add(children); } } //排序 Collections.sort(lockNodes); //如当前节点为最小节点，则成功获取锁 if (currentNode.equals(lockNodes.get(0))) { locked = true; } return locked; } catch (InterruptedException | KeeperException e) { logger.error(e.getMessage(), e); throw new RuntimeException(e); } } /** * Zookeeper分布式锁 * 实现思路： * 使用Zookeeper最小节点的方式 * 执行过程： * 1、创建根节点，在根节点下创建顺序节点 * 2、如当前创建的节点为根节点的所有子节点中最小的，则获取锁成功； * 否则，找到当前节点的前一个节点，watch前一个节点，当前一个节点被删除时获得锁；另外，等待超时也不能获得锁 */ @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { //等待锁 try { if (tryLock()) { return locked; } //找到当前节点的前一个节点 waitNode = lockNodes.get(Collections.binarySearch(lockNodes, currentNode) - 1); waitLock(time, unit); return locked; } catch (KeeperException e) { logger.error(e.getMessage(), e); throw new RuntimeException(e); } } /** * 释放锁 */ @Override public void unlock() { try { zooKeeper.delete(lockNamespace + &quot;/&quot; + currentNode, -1); zooKeeper.close(); locked = false; } catch (InterruptedException | KeeperException e) { logger.error(e.getMessage(), e); } } @Override public Condition newCondition() { return null; } /** * 等待锁 */ private void waitLock(long time, TimeUnit unit) throws KeeperException, InterruptedException { String waitLock = lockNamespace + &quot;/&quot; + waitNode; logger.debug(&quot;等待锁 {} 释放&quot;, waitLock); Stat stat = zooKeeper.exists(waitLock, watchedEvent -&gt; { if (countDownLatch != null) { locked = true; countDownLatch.countDown(); } }); //前一个节点此刻存在，等待，节点消失则成功获取锁 if (stat != null) { countDownLatch = new CountDownLatch(1); countDownLatch.await(time, unit); countDownLatch = null; } else { //前一个节点此刻不存在，获得锁 locked = true; } } /** * 确保根节点存在 */ private void ensureNameSpaceExist(String lockNamespace) throws KeeperException, InterruptedException { Stat statS = zooKeeper.exists(lockNamespace, false); if (statS == null) { //如果根节点不存在，创建 zooKeeper.create(lockNamespace, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); } } /** * 确保zookeeper连接成功，防止出现连接还未完成就执行zookeeper的get/create/exsit操作出现错误KeeperErrorCode = ConnectionLoss */ private void ensureZookeeperConnect() throws InterruptedException { CountDownLatch connectedLatch = new CountDownLatch(1); zooKeeper.register(watchedEvent -&gt; { if (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected) { connectedLatch.countDown(); } }); //zookeeper连接中则等待 if (ZooKeeper.States.CONNECTING == zooKeeper.getState()) { connectedLatch.await(); } } 3、最后另外推荐Redis、Zookeeper分布式锁的第三方实现Redisson、Curator锁。 完整代码（包括单元测试以及Redisson、Curator锁的使用）","tags":[{"name":"Java","slug":"Java","permalink":"http://yk95.top/tags/Java/"},{"name":"Redis","slug":"Redis","permalink":"http://yk95.top/tags/Redis/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"http://yk95.top/tags/ZooKeeper/"},{"name":"分布式锁","slug":"分布式锁","permalink":"http://yk95.top/tags/分布式锁/"}]},{"title":"使用Hexo搭建个人Github博客","date":"2017-05-29T16:00:00.000Z","path":"2017/05/30/使用Hexo搭建个人Github博客/","text":"参考网上的文章总算把自己的Github博客搭建出来了，在这把我的搭建步骤分享给大家，后面的内容还包括了配置域名，如已搭建成功了想要使用自己的域名访问博客可以直接跳到配置域名部分。搭建个人博客-hexo+github详细完整步骤零基础免费搭建个人博客-hexo+github上面两个链接是我所参考的文章，写的也很详细，如果没看懂我的步骤也可以看看上面的。 一、准备我们需要安装Git、Node.js、Hexo以及注册一个GitHub账号。下载Git、Nodejs可以选择在官网下载，也可以去CSDN下载，大部分都是不需要积分的。PS：官网下载网速超级慢，不知道是资源问题还是墙的原因。Git官网下载地址Node.js官网下载地址Git CSDN下载Node.js CSDN下载 1、安装Git 打开Git安装程序，点击NEXT来到这个页面，选择要安装的组件，可以全选也可以默认，然后一路NEXT即可，安装路径根据自己习惯更改。 2、安装Node.js同样打开Node.js安装程序，一路默认即可，安装路径根据自己习惯更改。 3、安装Hexo安装Hexo就稍微繁琐点，不过大家一定不能急，耐心等待安装，一般来说按照步骤慢慢来都是没有问题的。首先在任意地方右键，点击“Git Bash Here”。使用NPM命令安装，为防止被墙，这里使用淘宝NPM镜像，输入命令 npm install -g cnpm --registry=https://registry.npm.taobao.org 等待安装完成。 完成后，继续输入命令 cnpm install -g hexo-cli 等待完成，再输入命令 cnpm install hexo --save 至此Hexo安装完成，使用查看版本命令 hexo -v 检查是否正常安装。 4、注册Github以及创建仓库接下来我们注册Github账号，使用常用邮箱注册即可，过程比较简单这里就不细讲了。注册成功登录后，来到我的仓库页面，点击New repository。 注意Repository name一定得是yourname.github.io，这样才能使用这个地址访问到你的Github page，填好Repository name，点击Create repository。（我这里因为之前创建过，所以报同名错误，大家第一次创建的话可以忽略）。 在零基础免费搭建个人博客-hexo+github里有个‘启用GitHub Page’的步骤，但我发现页面都已经变得不一样了，最新的页面如下所示，只需要Choose Theme就会自动启用Github Page。 创建仓库后我们后面的步骤需要用到仓库地址，进到yourname.github.io仓库页面，看下图。 二、本地启动与部署到Github1、本地启动创建一个新文件夹（我的是在E盘创建的Blog），进入该文件夹，右键Git Bash Here，输入 hexo init 命令。PS：由于博主搭建成功后并没有推倒再来一遍，所以到这里就没有截图了，大家键入命令后，在程序运行过程记得一定要耐心等待。 初始化成功后，大概是下面的目录结构（我这个是部署到git后，有多了几个文件）。 接下来输入 hexo s -g 命令启动，启动后浏览器访问localhost:4000查看博客效果。 2、部署到Github本地成功后下面就要部署到Git了，打开_config.yml进行配置，如下图，复制你的仓库地址给repo参数(上面有讲怎么复制）。 在Git命令窗口输入 npm install hexo-deployer-git --save 安装hexo-deployer-git自动部署发布工具，等待安装完成，输入 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 命令发布到Github，这里注意第一次发布的话会需要输入你的Github账号跟密码，等待出现下图的信息就说明发布成功了，在浏览器输入yourname.github.io就可以看到你的博客了。 三、选择主题与配置域名1、选择主题完成上面的步骤之后呢，可能有人会觉得默认的Hexo主题不是特别好看（至少博主是那么认为的），所以我们可以给博客选择一个适合自己的主题，使用命令 git clone https://github.com/iissnan/hexo-theme-nextthemes/[theme] 来下载一个新的主题，[theme]为主题名。下载完成后，修改_config.yml的theme参数来配置主题，见下图。 附上链接：有哪些好看的 Hexo 主题？ 博主选择的主题是yilia，这里遇到了一个坑：使用yilia主题有了两个_config.yml文件，一个是我们一直用到的，另一个是yilia主题目录下的，启用yilia的某些功能需要在我们一直用到的_config.yml文件配置，而yilia主题的定制是在yilia目录下的_config.yml配置，其他主题可能也会有这样的情况，这一点稍微注意下。 另附上yilia主题的评论配置：多说、畅言、网易云跟帖、Disqus评论配置 2、配置域名这一步骤提供给需要使用自己的域名访问Github page的读者，不需要的可以直接跳过。在cmd窗口使用 ping yourname.github.io 得到IP地址，见下图。 在你的Github博客仓库根目录下创建CNAME文件，注意不能有文件名不能有后缀且要大写，内容为你想指定的域名。 然后将你的域名映射到该IP地址，这里以博主的阿里云购买的域名举例，在阿里云域名控制台添加一条解析，如下图。 等解析生效就可以使用域名访问Github page了，例如博主的：http://yk95.top 使用域名访问Github page还需要注意一点，我们使用 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 命令将博客发布到Git时，Hexo会将整个仓库全部清空，然后才提交，这样我们创建的CNAME文件就被删除了，这里提供一个简单的解决方案，在本地博客public文件夹下创建CNAME文件，发布到Git时不clean使用 hexo g &amp;&amp; hexo d 命令，发布时会将CNAME文件一起提交。 四、发布自己的第一篇博客将博客搭建起来之后就可以开始写博客了，首先需要配置一些基本信息，这些内容不会解析到博客正文中，见下图。 接下来就是正式写博客正文了，写的文章要遵循markdown语法。附上链接：Markdown 语法说明 (简体中文版)写好博客后就可以使用命令 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 发布到Github了（域名访问的请去掉 hexo clean），下面是博客效果。 至此，本篇博客搭建教程介绍完毕，最后再附上一些链接：Hexo博客添加百度sitemapHexo插件之百度主动提交链接用阿里云的免费 SSL 证书让网站从 HTTP 换成 HTTPS","tags":[{"name":"Github","slug":"Github","permalink":"http://yk95.top/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yk95.top/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://yk95.top/tags/博客/"}]}]